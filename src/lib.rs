//! This crate aims to encapsulate the logic required for building `libjq`
//! from source (so that [jq-sys] doesn't have to know how to do this).
//!
//! The primary consumers of this crate are [jq-sys] (the generated bindings
//! to `libjq`), and indirectly [json-query] (a high-level wrapper for running
//! _jq programs_ over json strings).
//!
//! [jq-sys]: https://github.com/onelson/jq-sys
//! [json-query]: https://github.com/onelson/json-jquery

extern crate autotools;

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

/// Get the path to the jq source.
///
/// This file path represents the location of the git submodule registered
/// in with this crate's repo.
/// These sources are copied to the _out dir_ during the build before
/// compilation begins.
pub fn source_dir() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("modules")
        .join("jq")
}

/// Get the current version of the crate.
pub fn version() -> &'static str {
    env!("CARGO_PKG_VERSION")
}

/// Information about the locations of files generated by `Build::build()`.
///
/// After the jq sources have been compiled, the fields in this struct
/// represent where the various files ended up, and what sort of build was
/// done (ie, static or dynamic).
pub struct Artifacts {
    include_dir: PathBuf,
    lib_dir: PathBuf,
    libs: Vec<String>,
    link_static: bool,
}

impl Artifacts {
    /// Prints cargo instructions for linking to the bundled `libjq`.
    pub fn print_link_info(&self) {
        println!("cargo:include={}", self.include_dir.display());
        println!("cargo:rustc-link-search=native={}", self.lib_dir.display());
        let statik = if self.link_static { "static=" } else { "" };
        for lib in &self.libs {
            println!("cargo:rustc-link-lib={}{}", statik, lib);
        }
    }

    pub fn include_dir(&self) -> &Path {
        &self.include_dir
    }

    pub fn lib_dir(&self) -> &Path {
        &self.lib_dir
    }

    pub fn libs(&self) -> &[String] {
        &self.libs
    }
}

/// Configuration data for the build.
pub struct Build {
    link_static: bool,
    out_dir: Option<PathBuf>,
}

impl Build {
    pub fn new() -> Build {
        Build {
            link_static: env::var("JQ_NO_STATIC")
                .map(|s| !s.trim().is_empty())
                .unwrap_or(true),
            out_dir: env::var_os("OUT_DIR").map(|s| PathBuf::from(s).join("jq-build")),
        }
    }

    pub fn link_static(&mut self, value: bool) -> &mut Build {
        self.link_static = value;
        self
    }

    pub fn out_dir<P: AsRef<Path>>(&mut self, path: P) -> &mut Build {
        self.out_dir = Some(path.as_ref().to_path_buf());
        self
    }

    pub fn build(&mut self) -> Artifacts {
        let out_dir = self.out_dir.as_ref().expect("OUT_DIR not set");
        let build_dir = out_dir.join("build");
        let inner_dir = build_dir.join("src");

        if inner_dir.exists() {
            fs::remove_dir_all(&inner_dir).unwrap();
        }

        fs::create_dir_all(&inner_dir).unwrap();
        cp_r(&source_dir(), &inner_dir);

        let mut make_args = vec![];

        if self.link_static {
            make_args.push("LDFLAGS=-all-static".to_string());
        }

        autotools::Config::new(&inner_dir)
            .reconf("-ivf")
            .out_dir(out_dir)
            .disable("-maintainer-mode", None)
            .with("-oniguruma", Some("builtin"))
            .make_args(make_args)
            .build();

        fs::remove_dir_all(&inner_dir).unwrap();

        Artifacts {
            lib_dir: out_dir.join("lib"),
            include_dir: out_dir.join("include"),
            libs: vec!["jq".to_string(), "onig".to_string()],
            link_static: self.link_static,
        }
    }
}

fn cp_r(src: &Path, dst: &Path) {
    for f in fs::read_dir(src).unwrap() {
        let f = f.unwrap();
        let path = f.path();
        let name = path.file_name().unwrap();
        let dst = dst.join(name);
        if f.file_type().unwrap().is_dir() {
            fs::create_dir_all(&dst).unwrap();
            cp_r(&path, &dst);
        } else {
            let _ = fs::remove_file(&dst);
            fs::copy(&path, &dst).unwrap();
        }
    }
}
